{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the GENIE Python package","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The GENIE project provides mutation data for a large number of patients and cancer indications. However, many different panels are used for generating the data, and these panels have different coverage of tested genomic ranges. Therefore, to get the mutation profile of genes across samples it needs to be checked whether a particular genomic region is tested by a panel. If a sample is tested with a panel not covering a region of interest, the mutational status of this sample is unknown.</p> <p>The <code>genie</code> package provides means to get mutation profiles of genes for all samples where the gene has actually been tested. Such profiles can then also be used to estimate the frequency of mutations in a disease indication.</p> <p>Please see also some comments on the GENIE data for observations that I made while working on this package.</p>"},{"location":"analysis_details/","title":"Analysis Details","text":""},{"location":"analysis_details/#integrating-mutations","title":"Integrating mutations","text":""},{"location":"analysis_details/#issue-panels-have-different-coverage","title":"Issue: panels have different coverage","text":"<p>When multiple mutations need to be integrated, for example to derive a gene-level mutation status, it becomes difficult if there are functionally relevant mutations that are not measured by all the panels used for the patients in a cohort of interest.</p> <p>For example, some hotspot panels test only for selected mutations in target genes: </p> <p></p>"},{"location":"analysis_details/#solution","title":"Solution","text":"<p>To solve this issue, samples that are tested with panels not measuring the majority of mutations will be excluded:</p> <ol> <li>Identify all mutations found in a cohort of interest.</li> <li>Identify panels that do not test a predefinied minimum percentage of these    mutations (<code>panel_coverage_threshold</code>, default is 80%).</li> <li>Remove all samples tested with these panels of insufficient coverage.</li> </ol> <p>However, even high-density assays do not have identical coverage of genes or genomic regions:</p> <p></p> <p>That is, there may still be functionally relevant mutations that are only measured by a subset of high-density panels. For all samples measured by other panels, the gene-level mutation status would be uncertain. </p> <p>Even worse, there may not be a single panel that measures all variants found in a patient cohort.</p> <p>To test whether this is really an issue, I examined the mutation-versus-panel matrix and determined for each mutation how many panels measure that variant. This was only done for variants that affect the amino acid sequence, as intergenic or intronic variants may not be reported by all panels.</p> <p>For example, there are 32218 amino acid modifying variants that are only measured by two panels. I had a closer look into one of these variants, which was only measured by DFCI-ONCOPANEL-3 and DFCI-ONCOPANEL-3.1. There are 22,771 patients with samples profiled with these panels. Excluding all 149,234 patients profiled with other panels would not be useful. And assuming that the variant is wild type for all other 149,234 patients would also not be correct.</p>"},{"location":"analysis_details/#exact-approach","title":"Exact approach","text":"<p>Retain only patients profiled with panels that test for all mutations found in any of the patients in the cohort (set <code>panel_coverage_threshold</code> to 100%). The disadvantage is that the number of patients can be quite be small, resulting in large confidence intervals for the calculated mutation frequencies.</p>"},{"location":"analysis_details/#approximative-approach-1-imputation-of-missing-values","title":"Approximative approach 1 - imputation of missing values","text":"<p>Impute the mutation status of variants that were not tested by a panel using MICE (Multiple Imputation by Chained Equations):</p> <ol> <li>MUT is encoded as 1, WT as 0.</li> <li>The imputation will result in a fractional number between 0 and 1 for    each missing value.</li> <li>Random numbers (uniformly distributed between 0 and 1) are used to assign    \u201cMUT\u201d or \u201cWT\u201d to missing values depending on the value of the random variable    and on the imputed value from MICE. The originally missing value gets a \u201cMUT\u201d    if the random number is larger than the imputed value from MICE, and \u201cWT\u201d    otherwise.</li> </ol>"},{"location":"analysis_details/#approximative-approach-2-set-missing-values-to-wild-type","title":"Approximative approach 2 - set missing values to wild type","text":"<p>Here the assumption is that the most frequent mutations will be measured by all high-density panels. The remaining variants will then have lower allele frequencies, and the number of patients where this mutation is present but not detected is small. Setting the missing values to wild type will only slightly underestimate the true allele frequency.</p>"},{"location":"analysis_details/#comparison-of-the-two-approximate-approaches","title":"Comparison of the two approximate approaches","text":"<p>Although imputation has the potential to provide more accurate mutation frequencies, it is computationally very expensive, leading to long run times. In many cases, the differences to the frequencies obtained when setting missing values to wild type (after applying the <code>panel_coverage_threshold</code>) are small and within the confidence interval. Therefore, for many applications it may be appropriate to use the faster approach of setting missing values to wild type.</p>"},{"location":"analysis_details/#determining-co-occurrence-of-mutations","title":"Determining co-occurrence of mutations","text":"<p>It does not make sense to first identify all mutations in a cohort and then search for co-mutations, as this is very time-consuming and probably also requires too much memory space.</p> <p>There are different levels of co-occurrence. It could be co-occurrence at gene level, for example, co-occurrence of KRAS and BRAF mutations. Or, it can be and individual amino acid or even nucleotide variant level. For example, which genes have a functionally relevant mutation in samples with a KRAS G12C mutation.</p> <p>Therefore, here is an approach that should be feasible:</p> <ol> <li>Define a small number of genes of interest (in many cases, just one gene).</li> <li>Define indications of interest.</li> <li>Get all annotated unique mutations from entire GENIE for these gene(s) of    interest.</li> <li>Filter these mutations according to the question (for example, keep only    particular variants, or only variants with known or likely functional    impact).</li> <li>Identify of all samples from the indications of interest that carry at least    one of the filtered mutations of the gene(s) of interest, i.e. determine the    mutation status at gene level of all samples from the indications of interest    based on the filtered mutations.</li> <li>Find all mutations of any other genes in samples that are mutated at gene    level for the gene(s) of interest.</li> <li>Filter these mutations of other genes based on the annotation of unique    mutations, e.g. by keeping only protein-altering mutations. It would be    helpful to base this filter on the type of gene (oncogene, tumor suppressor    gene, other gene), but this should be the subject of a separate package to be    developed.</li> <li>Determine the gene level mutation status for all samples of the indications    of interest and for all genes left after filtering in the previous step. </li> <li>We now have the gene level mutation status for the gene(s) of interest and    for all other genes that are co-mutated with the gene(s) of interest in at    least one sample. This final result table is created by concatenating the    gene level mutation table for the gene(s) of interest and the gene level    mutation table for the co-mutated genes. Follow-up analyses depend very much    on the type of question, for example, are some of these co-mutated genes more    or less frequently mutated in the group of samples with a mutation in the    gene(s) of interest (Fisher's Exact Test would be appropriate here). Or    simply what is the frequency of mutations of the co-mutated genes in the    group of samples with a mutation in the gene(s) of interest.</li> </ol>"},{"location":"annotate/","title":"Annotating mutations","text":"<p>The panels included in GENIE do not consistently use left-shifted specifications of genomic variants. As a consequence, two samples that were tested with different panels may carry the same mutation, but the specification of the mutation (chromosome, position, reference allele, alternative allele) can be different. Another issue is that some panels report a \"-\" in the reference allele column for insertions or for the alternative allele for deletions. This is not consistent with the VCF file format standard and breaks downstream tools. </p> <p>For these reasons, the specification of mutations must be normalized by adding the missing leftmost nucleotide of indels, and left-shifting mutations, resulting in HGVSG designations of the normalized variants.</p> <p>This is a multi-step process and needs to be done only once for every new GENIE release.</p>"},{"location":"annotate/#step-1-prepare-the-reference-genome","title":"Step 1: Prepare the reference genome","text":"<p>For adding the missing nucleotide left of inserations or deletions, the genomic sequence is required.</p>"},{"location":"annotate/#download-reference-sequence","title":"Download reference sequence","text":"<p>download_reference.sh</p> <pre><code>GENCODE_DIR=$HOME/gencode\nmkdir -p $GENCODE_DIR\ncd $GENCODE_DIR\nFILE=\"GRCh37.primary_assembly.genome.fa.gz\"\nURL=\"https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/\\\nlatest_release/GRCh37_mapping/$FILE\"\ncurl $URL &gt; $HOME/$FILE\n</code></pre>"},{"location":"annotate/#bgzip-and-index-reference-sequence","title":"Bgzip and index reference sequence","text":"<p>reformat_genome.sh</p> <pre><code>zcat GRCh37.primary_assembly.genome.fa.gz \\\n| bgzip &gt; GRCh37.primary_assembly.genome.fa.bgz\nsamtools faidx GRCh37.primary_assembly.genome.fa.bgz\n</code></pre>"},{"location":"annotate/#create-chromosome-specific-fasta-files","title":"Create chromosome specific FASTA files","text":"<p>A subdirectory with one FASTA file for each chromosome needs to be provided. The genome FASTA file can be split into chromosome specific files using the Python script <code>extract_sequences.py</code> which is part of this GitHub repository and also included here:</p> extract_sequences.py <pre><code># Author: Henrik Seidel\n# Date: 2018-07-03\n# This script extracts all sequences from a fasta file into single sequences\n\nimport sys\nimport os.path\nimport gzip\nimport re\n\nif len(sys.argv) != 3:\n    sys.exit(\"ERROR: you have to specify the name of the fasta file \" +\n    \"and the name of the output directory\")\n\nfile_name = sys.argv[1]\nout_dir = sys.argv[2]\n\n# Assert we have a filename as first argument\nif not(os.path.isfile(file_name)):\n    sys.exit(\"ERROR: No such file: \\\"\" + file_name + \"\\\"\")\n\n# Assert the name of the output directory is okay\nif not(os.path.exists(out_dir)):\n    os.mkdir(out_dir)\nelif not(os.path.isdir(out_dir)):\n    sys.exit(\"ERROR: \\\"\" + out_dir + \"\\\" exists but is not a directory\")\n\n# Choose function for opening file, depending on compression status of file\nif (file_name.endswith(\".gz\") or file_name.endswith(\".bgz\")):\n    this_open = gzip.open\n    file = gzip.open(file_name, mode = \"rt\")\nelse:\n    this_open = open\n\nn = 0\nwith this_open(file_name, mode = \"rt\") as file:\n    out_file = None\n    try:\n        for line in file:\n            if line.startswith(\"&gt;\"):\n                if out_file is not None:\n                    out_file.close()\n                seq_name = re.match(\"^&gt;([^ ]+)\", line)[1]\n                n += 1\n                out_file_name = '{:s}/{:03d}_{:s}.fa'.format(out_dir, n, seq_name)\n                print('Writing {:s} to {:s}'.format(seq_name, out_file_name))\n                out_file = open(out_file_name, mode = \"wt\")\n            out_file.write(line)\n    finally:\n        out_file.close()\n</code></pre> <p>split_genome.sh</p> <pre><code>mamba activate genie\npython extract_sequences.py GRCh37.primary_assembly.genome.fa.bgz chr\nbzgip chr/*.fa\n</code></pre> <p>Required directory structure:</p> Directory structure of genome sequence files <pre><code>$HOME/gencode\n\u251c\u2500\u2500 GRCh37.primary_assembly.genome.fa.bgz\n\u251c\u2500\u2500 GRCh37.primary_assembly.genome.fa.bgz.fai\n\u251c\u2500\u2500 GRCh37.primary_assembly.genome.fa.bgz.gzi\n\u251c\u2500\u2500 GRCh37.primary_assembly.genome.fa.gz\n\u2514\u2500\u2500 chr\n \u00a0\u00a0 \u251c\u2500\u2500 001_chr1.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 002_chr10.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 003_chr11.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 004_chr12.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 005_chr13.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 006_chr14.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 007_chr15.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 008_chr16.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 009_chr17.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 010_chr18.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 011_chr19.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 012_chr2.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 013_chr20.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 014_chr21.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 015_chr22.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 016_chr3.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 017_chr4.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 018_chr5.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 019_chr6.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 020_chr7.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 021_chr8.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 022_chr9.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 023_chrM.fa.gz\n \u00a0\u00a0 \u251c\u2500\u2500 024_chrX.fa.gz\n \u00a0\u00a0 \u2514\u2500\u2500 025_chrY.fa.gz\n</code></pre>"},{"location":"annotate/#step-2-generate-a-vcf-file-of-all-genie-mutations","title":"Step 2: Generate a VCF file of all GENIE mutations","text":"<p>A VCF file is required for annotating mutations. All mutations from the GENIE file <code>data_mutations_extended.txt</code> will be extracted and transformed to a VCF file by the script <code>create_vcf.py</code> which is part of the GitHub genie project.</p> <p>Warning</p> <p>Before calling <code>create_vcf.py</code> you need to edit the first lines where directory locations are defined.</p> <p>create_vcf.sh</p> <pre><code># Please be patient, this takes about 6 minutes\nmamba activate genie\npython create_vcf.py\n</code></pre>"},{"location":"annotate/#step-3-normalize-the-vcf-file","title":"Step 3: Normalize the VCF file","text":"<p>Normalizing the VCF file before annotating it with Illumina Connected Annotations (previously known as Nirvana) is currently necessary because otherwise the mapping between samples and mutations is lost. This will change with forthcoming releases of Illumina Connected Annotations which will transfer the variant identifiers from the VCF ID column to the JSON output file of the annotator.</p> <p>Warning</p> <p>Before calling <code>normalize_vcf.sh</code> you need to edit the first lines where the directory location and the environment name are defined.</p> <p>normalize_vcf.sh</p> <pre><code>./normalize_vcf.sh\n</code></pre>"},{"location":"annotate/#step-4-annotate-mutations-from-the-normalized-vcf-file","title":"Step 4: Annotate mutations from the normalized VCF file","text":"<p>The VCF file needs to be annotated with Illumina Connected Annotations (previously known as Nirvana). See the documentation of the <code>icaparser</code> package on how to set up and use the annotator. The <code>genie</code> GitHub project contains two scripts for running the annotator - <code>run_ica.sh</code> and <code>run_ica_docker.sh</code>. Use one of these two scripts for annotating the VCF file, depending on how you installed the annotator.</p> <p>Example for running the annotator</p> <pre><code># This takes about 5 minutes\n./run_ica_docker.sh ../Data/Original/genie-15.0/genie_normalized.vcf.bgz\nmv ../Data/Original/genie-15.0/genie_normalized.json* ../Results\n</code></pre>"},{"location":"annotate/#step-5-create-auxiliary-files-from-annotations","title":"Step 5: Create auxiliary files from annotations","text":"<p>The results of the annotator will be used to create two auxiliary files:</p> <ol> <li><code>genie.vcf_id_to_hgvsg.tsv.gz</code>: This file contains a mapping between variant    identifiers and the normalized hgvsg specification of mutations. </li> <li><code>genie.annot.tsv.gz</code>: This file contains annotation of all variants from the    VCF file.</li> </ol> <p>These files are created by the Jupyter notebook <code>genie_create_aux_files.ipynb</code> which is part of of the genie GitHub project. Please open this file in a Jupyter server, adjust directory names as needed, and run it. </p> <p>Warning</p> <p>Running the notebook will take about one hour, and requires a lot of memory. Make sure you use an instance with 64 GB RAM or more, and no memory intensive processes running in parallel.</p> <p>Note</p> <p>All required files are saved in the <code>Data/Original</code> directory subtree, although some of the files are derived files. This is not according to the standard guidelines. The rationale for this procedure is that in the end we want to have a single directory with all data files and auxiliary files needed by the <code>genie</code> Python module.</p>"},{"location":"annotate/#step-6-precompute-which-mutations-are-tested-by-which-panel","title":"Step 6: Precompute which mutations are tested by which panel","text":"<p>GENIE uses different panels (assays), and for determining mutation profiles and mutation frequencies it is important to know whether or not a panel tests a particular mutation. Determining this on the fly is extremely time consuming. Therefore, this needs to be precomputed for each new GENIE release.</p> <p>To be more specific, a big matrix will be precomputed with panels versus mutations, where mutations are all mutations detected in at least one sample. This matrix is then saved as a Parquet file <code>mutation_tested_by_panel.parquet</code>.</p> <p>This Python script makes use of the <code>genie</code> package. Because the <code>Programs</code> directory where the script <code>create_panel_tested_positions_cache.py</code> is located also contains the sources of the <code>genie</code> package in the subdirectory <code>genie</code>, it is necessary to change the working directory to somewhere else, like the home directory, when calling the script, to make sure that it picks up the package as it was installed by the previous Python environment setup step. If you fail to do so, you will get an error message concering the <code>genie</code> package.</p> <p>Precompute mutation_tested_by_panel.parquet</p> <pre><code># This takes about a day\ncd $HOME\nmamba activate genie\nSCRIPT=$HOME/genie/Programs/create_panel_tested_positions_cache.py\npython $SCRIPT\n</code></pre> <p>Warning</p> <p>This calculation takes about a full day. Make sure the S@S EZ instance has the stop scheduler turned off during that time.</p>"},{"location":"comments/","title":"Comments on the GENIE data","text":""},{"location":"comments/#mutations-are-not-normalized","title":"Mutations are not normalized","text":"<p>The mutations contained in GENIE are not always normalized (left-shifted). Insertions and deletions do not always include the leading common nucleotide. Therefore, one and the same genomic alteration may be reported differently by different assays. When mutations are aggregated across different panels, the specification of genomic alterations must be normalized.</p> <p>This is done by creating a VCF file from the GENIE mutation data, normalizing and re-annotating the VCF file (here we use Illumina Connected Annotations).</p>"},{"location":"comments/#genie-uses-ensembl-transcripts","title":"GENIE uses ENSEMBL transcripts","text":"<p>Although the annotation of mutations provided by GENIE contains also RefSeq transcripts, the RefSeq annotation is incomplete. Many mutations have only an ENSEMBL transcripts but no RefSeq transcript assigned. On the other hand, there is no alteration that has only an assigned RefSeq transcript but no ENSEMBL transcript.</p> <p>Based on this observation, there are several different options for creating a unified consistent annotation across panels:</p>"},{"location":"comments/#option-1-keep-ensembl-transcripts-reported-by-genie","title":"Option 1: Keep ENSEMBL transcripts reported by GENIE","text":"<p>Consistently re-annotate all genomic variants, extract annotations for the ENSEMBL transcripts contained in GENIE, and map these updated annotations to the genomic changes reported by GENIE, using the ENSEMBL transcript ID as a mapping link.</p> <p>This option keeps the annotation as close a possible to the original GENIE annotations and just ensures that we get consistent annotations across all assays.</p> <p>However, this option does not have any focus on MANE Select transcripts.</p>"},{"location":"comments/#option-2-focus-on-mane-transcripts","title":"Option 2: Focus on MANE transcripts","text":"<p>Clinical reporting of mutations should preferrably be based on MANE transcripts. GENIE is based on GRCh37, while MANE is defined for GRCh38. The NCBI has remapped the MANE transcript RefSeq sequences back to the GRCh37 genome. Ensembl did not do this. Although there is a mapping table from MANE transcripts to Ensembl transcripts of GRCh37, this does not cover all MANE transcripts and the GRCh37 transcripts are also not always identical to the MANE transcripts. Therefore, when focusing on MANE transcripts while working with the GRCh37 genome (which GENIE is based on), using RefSeq transcripts rather than Ensembl transcripts is preferrable.</p> <p>Focusing on MANE requires some additional decisions. If a genomic variant affects a MANE transcript, the consequence on that MANE transcript can be reported. Even then, it needs to be decided how to handle situations where both MANE Select and MANE Plus Clincial transcripts are affected.</p> <p>If a genomic variant does not affect a MANE transcript, there is no clear and obvious procedure as to which transcript to report. One could decide to report only effects on MANE transcripts and omit all genomic variants that do not affect a MANE transcript. Or one could decide to omit non-MANE transcripts for genes for which a MANE transcript is defined, even if the MANE transcript itself is not affected by a genomic variant, but to report none-MANE transcripts for genes for which no MANE transcript is defined. For such genes it still must be decided which of the non-MANE transcripts to report.</p> <p>So there are several different options when focusing on MANE. Unless the report is MANE-only, i.e. filters out any non-MANE transcript, it depends very much on the use case which transcripts to keep.</p>"},{"location":"comments/#conclusion","title":"Conclusion","text":"<p>The <code>genie</code> package provides two types of annotations, one is based on the ENSEMBL transcripts originally used by Genie, the other one is MANE-only and uses RefSeq. The <code>universe</code> argument of many <code>genie</code> functions can be used to select the annotation type.</p> <p>If an enhanced \"MANE + Non-MANE\" version is required, the file <code>genie.annot.tsv.gz</code> can be used as input for a customized filtering process outside of the <code>genie</code> package. This file was generated when creating the auxiliary files for a new GENIE release and contains annotations for all transcripts affected by a genomic variant.  </p>"},{"location":"download/","title":"Downloading data","text":""},{"location":"download/#downloading-genie-data","title":"Downloading GENIE data","text":"<p>The GENIE data need to be downloaded from Synapse.</p> <p>It is recommended to use the command line tool <code>synapse</code> for downloading the data. If you haven't done yet, install the <code>synapseclient</code> Python package.</p> <p>install_synapseclient.sh</p> <pre><code>pip install synapseclient\n</code></pre> <p>And then download the GENIE data into your current directory, here for version 15.0 of GENIE. Make sure you have registered for Synapse GENIE downloads and created a download token for Synapse, you will need it for authentication.</p> <p>download_genie.sh</p> <pre><code>synapse get -r syn53210170 # the number is different for each GENIE release\n</code></pre> <p>WARNING: Fixing the PROV-TRISEQ-V2 panel required.</p> <p>There is an open issue with the PROV-TRISEQ-V2 panel, please see the discussion on GENIE Synapse. To fix this issue, the script <code>fix_gene_panels.py</code> needs to be run once before using the <code>genie</code> package. This script will add a missing file for this panel in the <code>gene_panels</code> directory of the GENIE data.</p> <p>You have to edit the line <code>genie_dir</code> before calling <code>fix_gene_panels.py</code>.</p>"},{"location":"download/#downloading-mane-transcript-definitions","title":"Downloading MANE transcript definitions","text":"<p>Download the latest release of MANE_\\human from NCBI to the same directory where the genie data is stored. This is required for reannotating variants with MANE transcripts and for filtering for MANE transcripts.</p> <p>download_mane.sh</p> <pre><code>FILE=\"MANE.GRCh38.v1.3.summary.txt.gz\"\nURL=\"https://ftp.ncbi.nlm.nih.gov/refseq/MANE/MANE_human/current/$FILE\"\ncurl $URL &gt; $FILE\n</code></pre> <p>Don't forget to update <code>default_config.json</code></p> <p>The file name of the MANE definition file is configured in <code>default_config.json</code> in the <code>genie</code> GitHub repository. If you download a new release of MANE, the filename in the config file needs to be updated.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page lists some examples on how to use the genie package.</p>"},{"location":"examples/#kras-g12c","title":"KRAS G12C","text":"Program: kras_k12c.py Result: KRAS_G12C_GENIE_15.0.xlsx <p>This program creates an Excel file with the frequencies of KRAS G12C mutations in non-small cell lung cancer (NSCLC) and in colorectal cancer (CRC).</p> <p>Frequencies are provided for all NSCLC and for all CRC samples, as well as for some cancer subtypes:</p> <ul> <li>NSCLC: LUAD (lung adenocarcinoma), LUSC (lung squamous cell carcinoma), other, all</li> <li>CRC: COAD (colon adenocarcinoma), READ (rectal carcinoma), COADREAD (colorectal carcinoma), other, all</li> </ul> <p>Frequencies are provided for each race (White, Black, Asian, other, all).</p>"},{"location":"examples/#her2-erbb2-top-cancers-by-race","title":"HER2 (ERBB2) - top cancers by race","text":"Program: her2_top.py Result: HER2_GENIE_15.0_top_cancers.xlsx <p>This program creates an Excel file with the frequencies of all amino acid variants found in the five cancer types with the most frequent HER2 mutations:</p> <ul> <li>bladder cancer</li> <li>small bowel cancer</li> <li>cervical cancer</li> <li>non-small cell lung cancer</li> <li>esophagogastric cancer</li> </ul> <p>Separate frequencies are provided for the mosts frequent subtypes of these cancers. Furthermore, separate allele frequencies are provided for each race (White, Black, Asian, other, all).</p>"},{"location":"examples/#her2-erbb2-top-cancers-by-tmb","title":"HER2 (ERBB2) - top cancers by TMB","text":"Program: her2_with_tmb.py Result: HER2_GENIE_15.0_top_cancers_with_tmb.xlsx <p>This program creates an Excel file with the frequencies of all HER2 amino acid variants found in the five cancer types with the most frequent HER2 mutations, same as described in the previous section, but here separate frequencies are provided for each tumor mutation burdon class (low, intermediate, high) instead of for each race.</p>"},{"location":"examples/#her2-erbb2-all-cancers","title":"HER2 (ERBB2) - all cancers","text":"Program: her2.py Result: HER2_GENIE_15.0_all_cancers.xlsx <p>This program creates an Excel file with the frequencies of all HER2 amino acid variants that are not functionally deleterious  (such as frame shifts, stop gained or lost, ...) for each cancer type. In addition to amino acid level mutation frequencies, gene level frequencies are provided.</p>"},{"location":"examples/#her2-erbb2-clinical-trial-indications-different-mutation-sets","title":"HER2 (ERBB2) - clinical trial indications, different mutation sets","text":"Program: her2_v2.py Result: HER2_GENIE_15.0_selected_cancers_gene_level.xlsx <p>This program creates an Excel file with the gene level mutation frequencies of HER2. Several definitions for the gene level were used. Each of these definitions is based on a different set of amino acid changes, and HER2 is classified as mutated if a sample has at least one of the mutations from the respective set. The different mutation sets were defined by the HER2 project team:</p> <ul> <li>curated:   variants that have been curated as activating HER2 mutations</li> <li>phase3:    variants that have been selected as eligible for inclusion in the NSCLC Phase 3 clinical study</li> <li>tkd:       variants that are located in the Tyrosine Kinase Domain of HER2; TKD is defined as exons 18 - 22; Pfam TKD model matches AAs 721 - 975</li> <li>exon20ins: variants that are an inframe exon20 insertion mutation</li> <li>missense:  variants that are a SNV missense mutation</li> </ul>"},{"location":"installation/","title":"Overview","text":""},{"location":"installation/#preparations-for-using-the-genie-package","title":"Preparations for using the genie package","text":"<p>Before using the package, the GENIE data needs to be dowloaded and some additional derived data files need to be created. For example, the mutations in GENIE are not normalized (left-shifted). Therefore, the same mutation can be specified differently for different panels.</p>"},{"location":"installation/#step-1-setting-up-the-infrastructure","title":"Step 1: Setting up the infrastructure","text":"<p>Set up the environment, which mostly means creating a mamba environment and installing some Python packages and bioinformatics tools.</p>"},{"location":"installation/#step-2-preparing-genie-data","title":"Step 2: Preparing GENIE data","text":"<p>This is required whenever a new GENIE release is published. Required steps:</p> <ol> <li>Download the data</li> <li>Annotate mutations</li> </ol>"},{"location":"overview/","title":"Package overview","text":""},{"location":"overview/#main-class-genie","title":"Main class <code>Genie</code>","text":"<p>The class <code>Genie</code> is the main class of the <code>genie</code> package. A <code>Genie</code> object contains all data of a Genie release and the results of a re-annotation of mutations based on Illumina Connected Annotations (previously known as Nirvana).</p> <p>How to create a Genie object</p> <pre><code># Loading all data takes about 2 minutes.\nimport genie.genie as gd\ngenie_dir = \"/my/path/to/genie-&lt;version&gt;\"\ng = gd.Genie(genie_dir)\nprint(g.summary())\n</code></pre>"},{"location":"overview/#other-data-classes","title":"Other data classes","text":"<p>Other classes defined by the <code>genie</code> package store the different data types provided by the Genie consortium. Objects of the main class <code>Genie</code> have instances of these classes as members (attributes).</p> <ul> <li><code>PatientInfo</code>: clinical data of patients.</li> <li><code>SampleInfo</code>: sample annotation.</li> <li><code>Mutations</code>: mutation data (SNVs and InDels) and mutation annotations.</li> <li><code>CNA</code>: copy number alteration data.</li> <li><code>Panel</code>: information about a single panel (annotation and content).</li> <li><code>PanelSet</code>: all <code>Panel</code>s included in Genie.</li> <li><code>TestedPositions</code>: all positions tested by any <code>Panel</code> from the <code>PanelSet</code>.</li> <li><code>Meta</code>: meta information on data files.</li> </ul>"},{"location":"overview/#configuration","title":"Configuration","text":"<p>The <code>Configuration</code> class stores the names of original data files provided by Genie and of auxiliary files derived from these original data files. The names of these files are defined in a JSON configuration file that is part of the <code>genie</code> module. Users can provide a custom configuration file to override some of the predefined file names if a new Genie version changes names.</p> <p>The <code>Configuration</code> class also provides some functions for loading data files and auxiliary files as Pandas DataFrames. The data is read from cache files in Parquet format. If a cache file does not exist yet, it is automatically created from the original TSV file on the fly.</p>"},{"location":"overview/#details-of-data-analysis","title":"Details of data analysis","text":"<p>Please see the Analysis Details for a description how individual mutations are aggregated to gene level and how co-mutations are detected.</p>"},{"location":"python_env/","title":"Setting up the environment","text":""},{"location":"python_env/#introduction","title":"Introduction","text":"<p>Some preparations are required before downloading the GENIE data and  creating additional auxiliary files needed by the <code>genie</code> package. Please follow the instructions below to set up your environment.</p>"},{"location":"python_env/#install-mamba","title":"Install mamba","text":"<p>If you haven't done so already anyway, please install <code>mamba</code>, the next generation replacement for <code>conda</code>. One of the advantages of <code>mamba</code> is that it is much faster than <code>conda</code>.</p> <p>Please see the Mamba Installation Instructions on how to install <code>mamba</code>.</p>"},{"location":"python_env/#create-a-virtual-environment-for-genie","title":"Create a virtual environment for genie","text":"<p>Create and activate a virtual environment</p> <pre><code>mamba create -n genie\nmamba activate genie\n</code></pre>"},{"location":"python_env/#install-genie-package","title":"Install genie package","text":"<p>Install genie package</p> <pre><code>mamba install python pandas sinfo\npip install \"git+https://github.com/heseber/genie-parser.git\"\n</code></pre>"},{"location":"python_env/#install-packages-and-programs","title":"Install packages and programs","text":"<p>Install packages</p> Installation<pre><code>mamba install -c bioconda bcftools samtools\npip install synapseclient\n</code></pre>"},{"location":"python_env/#install-illumina-annotator-and-icaparser-module","title":"Install Illumina Annotator and icaparser module","text":"<p>For the normalization and annotation of mutations from GENIE, a working setup of Illumina Connected Annotations (previously known as Nirvana) and the <code>icaparser</code> module is needed. Setting up this environment is beyond the scope of this document, please see the documentation of <code>icaparser</code> for instructions.</p>"},{"location":"questions/","title":"Questions to be addressed by the module","text":"<p>This page lists questions that can be asked of the Genie data. Not all of them are already covered by the current library, so this document is also a support for the further development of the package.</p> <ol> <li>What is the frequency of any mutation of a gene per indication?</li> <li>What is the frequency of each amino acid change of a gene across the complete    GENIE patient population?</li> <li>What is the frequency of each amino acid change of a gene per indication?</li> <li>What is the frequency of a particular mutation/group of mutations per    indication?</li> <li>What is the frequency of homozygous loss of a gene per indication?</li> <li>What is the overlap of the mutation of interest in a certain indication with    other actionable mutations/drivers?</li> </ol>"},{"location":"reference/","title":"API documentation","text":""},{"location":"reference/#genie.genie.CNA","title":"<code>CNA(config)</code>","text":"<p>Copy number alteration data for all samples included in GENIE.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>             (<code>DataFrame</code>)         \u2013          <p>copy number data for all samples. HGNC gene symbol is row index, sample id is column index. If CNA information is missing for a gene-sample pair, the value is NaN.</p> </li> </ul>"},{"location":"reference/#genie.genie.CNA.get_cna","title":"<code>get_cna(sample_id, gene_symbol)</code>","text":"<p>Get copy number data for a single sample.</p> <p>Parameters:</p> <ul> <li> <code>sample_id</code>             (<code>str</code>)         \u2013          <p>sample identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>copy number (NaN if not measured).</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration","title":"<code>Configuration(genie_dir, config_file=None)</code>","text":"<p>Genie source data configuration.</p> <p>The default configuration is read from a default JSON config file which is part of the package. If a user config file is specified, it is used to update the information from the default config file.</p> <p>Parameters:</p> <ul> <li> <code>genie_dir</code>             (<code>str</code>)         \u2013          <p>the base directory name of the GENIE data files.</p> </li> <li> <code>config_file</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>optional user config file (JSON).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; import genie\n&gt;&gt;&gt; home = os.getenv(\"HOME\")\n&gt;&gt;&gt; genie_dir = os.path.join(home, \"genie_data\")\n&gt;&gt;&gt; user_config_file = os.path.join(home, \".genie_config.json\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Without a user config file (use only defaults)\n&gt;&gt;&gt; config = genie.Configuration(genie_dir)\n</code></pre> <pre><code>&gt;&gt;&gt; # With a user config file, overwriting some defaults\n&gt;&gt;&gt; config = genie.Configuration(genie_dir, user_config_file)\n</code></pre>"},{"location":"reference/#genie.genie.Configuration.get_aux_file_name","title":"<code>get_aux_file_name(key)</code>","text":"<p>Get the file name of an auxiliary data file.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>auxiliary data file identfier used in the config file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the file name for this auxiliary data file.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_cache_file_name","title":"<code>get_cache_file_name(file_name)</code>","text":"<p>Get the name of the Parquet cache file.</p> <p>The name of the cache file is created from the original file name by stripping the extensions and appending the suffix '.parquet'.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the name of the data file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the name of the cache file</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_case_list_file_names","title":"<code>get_case_list_file_names()</code>","text":"<p>Get all files with cast lists.</p> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>dictionary with disease names as keys and file names as values.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_config","title":"<code>get_config()</code>","text":"<p>Get the complete configuration data.</p> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>complete configuration as dictionary.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_data_file_name","title":"<code>get_data_file_name(key)</code>","text":"<p>Get the file name of a GENIE  data file.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>data file identfier used in the config file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the file name for this data file.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_dir","title":"<code>get_dir(key)</code>","text":"<p>Get a directory name from the configuration.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>directory identfier used in the config file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>directory name.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_gene_panel_file_names","title":"<code>get_gene_panel_file_names()</code>","text":"<p>Get all files with gene panel descriptions.</p> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>dictionary with panel IDs as keys and file names as values.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_genie_dir","title":"<code>get_genie_dir()</code>","text":"<p>Get the base directory of GENIE data.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>base directory name for GENIE data.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_genie_version","title":"<code>get_genie_version()</code>","text":"<p>Get the version of the GENIE release.</p> <p>The version is obtained from the study meta file.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>release version of GENIE data.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.get_meta_file_name","title":"<code>get_meta_file_name(key)</code>","text":"<p>Get the file name of a GENIE meta data file.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>meta data file identfier used in the config file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the file name for this meta file.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.load_aux_file","title":"<code>load_aux_file(key)</code>","text":"<p>Load auxiliary data from a file or file cache.</p> <p>Loads a dataframe from a file. The dataframe is read from the cache Parquet cache file if it exists. If the cache file does not exist yet, it will be created so that next time loading the data will be faster.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>auxiliary file identfier used in the config file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>the data loaded from the file or its cache.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.load_data_file","title":"<code>load_data_file(key)</code>","text":"<p>Load GENIE data from a file or file cache.</p> <p>Loads a dataframe from a file. The dataframe is read from the cache Parquet cache file if it exists. If the cache file does not exist yet, it will be created so that next time loading the data will be faster.</p> <p>Parameters:</p> <ul> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>data file identfier used in the config file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>the data loaded from the file or its cache.</p> </li> </ul>"},{"location":"reference/#genie.genie.Configuration.load_file","title":"<code>load_file(file_name)</code>","text":"<p>Load a dataframe from a file or file cache.</p> <p>Loads a dataframe from a file. The dataframe is read from the cache Parquet cache file if it exists. If the cache file does not exist yet, it will be created so that next time loading the data will be faster.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>             (<code>str</code>)         \u2013          <p>the name of the data file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>the data loaded from the file or its cache.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie","title":"<code>Genie(genie_dir, config_file=None, verbose=True)</code>","text":"<p>This is the main class for this module, holding all GENIE data.</p> <p>An object of this class holds and provides all data from a Genie release. This includes all panels (assays) and the genomic regions tested by each panel, patient information, sample information, copy number data, mutation data.</p> <p>Parameters:</p> <ul> <li> <code>genie_dir</code>             (<code>str</code>)         \u2013          <p>path name of the directory with Genie data files.</p> </li> <li> <code>config_file</code>             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>path name of an optional user config file, defining alternative names for GENIE data files if names should change for future versions of GENIE.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>panel_set</code>             (<code>PanelSet</code>)         \u2013          <p>all panels (assays) included in GENIE.</p> </li> <li> <code>patient_info</code>             (<code>PatientInfo</code>)         \u2013          <p>clinical information about patients.</p> </li> <li> <code>sample_info</code>             (<code>SampleInfo</code>)         \u2013          <p>sample annotations.</p> </li> <li> <code>cna</code>             (<code>CNA</code>)         \u2013          <p>copy number data.</p> </li> <li> <code>mutations</code>             (<code>Mutations</code>)         \u2013          <p>mutation data.</p> </li> <li> <code>version</code>             (<code>str</code>)         \u2013          <p>Genie version number.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.aggregate_to_amino_acid_level","title":"<code>aggregate_to_amino_acid_level(sample_mutation_profiles, gene_symbols, universe='ensembl')</code>","text":"<p>Aggregate mutations to gene level.</p> <p>This function aggregates the sample mutation level profiles to amino acid level. Several different nucleic acid changes can lead to the same amino acid change. These are aggregated by this function.</p> <p>The <code>gene_symbols</code> argument needs to be specified because a mutation can affect multiple genes, so the mapping from hgvsg to gene symbol is not unambigious.</p> <p>Parameters:</p> <ul> <li> <code>sample_mutation_profiles</code>             (<code>DataFrame</code>)         \u2013          <p>a single column dataframe with hgvsg and sample_id as row index and the boolean mutation status as column.</p> </li> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes of interest - the hgvsgs from the the mutation profiles may map to multiple genes, and only the gene symbols from this list will be kept.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of ensembl and mane, defines which annotations will be used to create the mapping from hgvsg to gene symbols.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>dataframe with two-dimensional row index (hgvsp, sample_id) and single column with the mutation status</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.aggregate_to_gene_level","title":"<code>aggregate_to_gene_level(sample_mutation_profiles, gene_symbols, universe='ensembl', min_mutations=1)</code>","text":"<p>Aggregate mutations to gene level.</p> <p>This function aggregates the sample mutation level profiles to gene level. A sample is called mutated for a gene if it has at least <code>min_mutations</code> of that gene. For oncogenes, <code>min_mutations</code> should  be kept at the default value of 1. For tumor suppressor genes, it may be desired to require at least two hits to call a sample mutated, assuming that the two hits would affect the two copies of that gene. Any filtering for the functional relevance of mutations needs to be done prior to calling this function.</p> <p>The <code>gene_symbols</code> argument needs to be specified because a mutation can affect multiple genes, so the mapping from hgvsg to gene symbol is not unambigious.</p> <p>Parameters:</p> <ul> <li> <code>sample_mutation_profiles</code>             (<code>DataFrame</code>)         \u2013          <p>a single column dataframe with hgvsg and sample_id as row index and the boolean mutation status as column.</p> </li> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes of interest - the hgvsgs from the the mutation profiles may map to multiple genes, and only the gene symbols from this list will be kept.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of ensembl and mane, defines which annotations will be used to create the mapping from hgvsg to gene symbols.</p> </li> <li> <code>min_mutations</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Call a gene mutated if it has at least that many mutations. Should be 1 for oncogenes and may be set to 2 for tumor suppressor genes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>dataframe with two-dimensional row index (gene, sample_id) and single column with the mutation status</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.append_patient_info","title":"<code>append_patient_info(more_info)</code>","text":"<p>Add more columns to the patient information data.</p> <p>Parameters:</p> <ul> <li> <code>more_info</code>             (<code>DataFrame</code>)         \u2013          <p>table with additional columns to be added to the patient information. This dataframe must have the <code>PATIENT_ID</code> as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>nothing</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.append_sample_info","title":"<code>append_sample_info(more_info)</code>","text":"<p>Add more columns to the sample information data.</p> <p>Parameters:</p> <ul> <li> <code>more_info</code>             (<code>DataFrame</code>)         \u2013          <p>table with additional columns to be added to the sample information. This dataframe must have the <code>SAMPLE_ID</code> as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>nothing</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_amino_acid_level_frequencies","title":"<code>get_amino_acid_level_frequencies(gene_symbols, hgvsgs=None, hgvsps=None, cancer_types=None, cancer_types_to_keep=None, cancer_subtypes=None, cancer_subtypes_to_keep=None, sample_ids=None, cancer_subtype_resolution=False, extra_group_columns=None, universe='ensembl', precision=1, panel_coverage_threshold=0.8, impute=False)</code>","text":"<p>Get amino acid level mutation frequencies.</p> <p>This function returns the amino acid level mutation frequencies of the specified genes across either all samples or across selected samples after filtering based on sample ids or cancer types or cancer subtypes. Counts and frequencies are for patient numbers, not sample numbers. A patient is considered having a particular mutation if at least one sample of this patient has that mutation.</p> <p>There may be several different nucleic acid mutations leading to the same protein sequence change. At amino acid level, these different nucleic acid variants are integrated to a an amino acid level, that is, a sample is considered mutated for a particular amino acid change if it has any of the nucleic acid changes leading to that amino acid variant, and it is considered wild type if it has none of these mutations.</p> <p>The number of genes should be small, because otherwise the volume of results is very high and it will take very long for the function to return.</p> <p>For each mutation detected in at least one sample, it is checked for each sample whether the mutation was tested by the panel used for this sample. Samples not tested for the majority of mutation (less than <code>panel_coverage_threshold</code>) are not included in the returned counts and frequencies. For the remaining samples, missing values are imputed or set to wild type, depending on the <code>impute</code> argument. See <code>get_imputed_sample_mutation_profiles</code> for details.</p> <p>If the <code>cancer_types_to_keep</code> argument is specified, all cancer types not included in this list are summarized in the <code>other</code> category.</p> <p>If the <code>cancer_subtypes_to_keep</code> argument is specified, all cancer subtypes not included in this list are summarized in the <code>other</code> category.</p> <p>If <code>extra_group_columns</code> is specified, counts are provided for each value of these extra columns. One example for this is <code>PRIMARY_RACE</code>. The argument <code>extra_group_columns</code> needs to be provided as a dictionary, where the dict key is the name of the column, and the dict value is a list of all values of that column for which an extra row in the count table will be provided, while other values will be summarized as <code>other</code>. For example, if counts shall be returned separately for the \"White\", \"Black\" and \"Asian\" population and the remaining patients shall be summarized as \"other\", the <code>extra_group_columns</code> argument needs to be set to <code>{\"PRIMARY_RACE\": [\"White\", \"Black\", \"Asian\"]}</code>. If no aggregation to an <code>other</code> category is desired, set the dict value to <code>None</code>. For example, <code>{\"PRIMARY_RACE\": None}</code> would return separate counts for each race.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes to include in the result.</p> </li> <li> <code>hgvsgs</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>keep only these hvsgs, i.e., exclude all other hgvsgs for the specified gene_symbols. If None, keep all hgvsgs.</p> </li> <li> <code>hgvsps</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>keep only these hgvsps, i.e., exclude all other hgvsps for the specified gene symbols. If None, keep all hgvsps.</p> </li> <li> <code>cancer_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types to include in the result. All if None.</p> </li> <li> <code>cancer_types_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types not to summarize in the other category. No summarization if None.</p> </li> <li> <code>cancer_subtypes</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes to include in the result (Oncotree codes). All if None.</p> </li> <li> <code>cancer_subtypes_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes not to summarize in the other category (Oncotree codes). No summarization if None.</p> </li> <li> <code>sample_ids</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Keep only these samples. No additional filtering if None.</p> </li> <li> <code>cancer_subtype_resolution</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, provide frequencies by cancer subtype, otherwise return frequencies summarized by cancer type. If cancer_subtypes_to_keep is specified, this is automatically set to True, otherwise it defaults to False.</p> </li> <li> <code>extra_group_columns</code>             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>by default, counts are returned for each combination of gene symbol, cancer type (CANCER_TYPE), and possibly cancer subtype (ONCOTREE_CODE). If counts should be split by additional factors, such as PRIMARY_RACE, it can be added here.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> <li> <code>precision</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>number of fractional digits of formatted allele frequency percentages.</p> </li> <li> <code>panel_coverage_threshold</code>             (<code>float</code>, default:                 <code>0.8</code> )         \u2013          <p>Exclude panels and samples profiled with these panels if the fraction of mutations tested by these panels is below that threshold. If this is set to 1, only panels that test all mutations are included. In that case, no imputation is needed. See <code>get_imputed_sample_muation_profiles</code> for details.</p> </li> <li> <code>impute</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to impute missing values (mutations not tested). If this is set to False (the default), then missing values are replaced with wild type. See <code>get_imputed_sample_muation_profiles</code> for details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>Amino acid level counts and frequencies.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_annotated_unique_mutations","title":"<code>get_annotated_unique_mutations(gene_symbols=None, universe='ensembl')</code>","text":"<p>Get annotated mutations for all or selected genes.</p> <p>This function returns a dataframe with all unique mutations found in at least one sample in Genie for the specified genes. If no genes are specified, return annotations for all genes.</p> <p>If the universe mane is specified, more than one transcript can be returned for a genomic variant, for example a MANE Select and a MANE Plus clinical variant.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>return mutations for these genes. If not specified, mutations for all genes will be returned.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>ensembl or mane. Return annotations for Ensembl transcripts or for MANE transcripts.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>dataframe with annotated unique mutations.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_cancer_subtype_sample_counts","title":"<code>get_cancer_subtype_sample_counts(cancer_types=None, cancer_subtypes_to_keep=None)</code>","text":"<p>Get cancer subtypes and their sample numbers.</p> <p>Get the number of samples for each cancer subtype included in Genie. This function returns sample numbers and not patient numbers because quite often patients have multiple samples of the same cancer type but slightly different cancer subtype annotations.</p>"},{"location":"reference/#genie.genie.Genie.get_cancer_subtypes","title":"<code>get_cancer_subtypes(cancer_types=None)</code>","text":"<p>Get cancer subtypes for all or selected cancer types.</p> <p>Parameters:</p> <ul> <li> <code>cancer_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>optional list of cancer types for which to return cancer subtypes. If not specified, all cancer types are returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>cancer subtypes for all or specified cancer types. Cancer types as index of the returned dataframe, Oncotree codes and and names of cancer subtypes as columns.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_cancer_type_patient_counts","title":"<code>get_cancer_type_patient_counts(cancer_types_to_keep=None)</code>","text":"<p>Get cancer types and their patient numbers.</p> <p>Get the number of patients for each cancer type included in Genie. If the optional argument <code>cancer_types_to_keep</code>is specified, all other cancer types are summarized as other.</p> <p>The counts returned are for patients, not samples. Patients can have more than one sample and even more than one cancer type. Each patient is counted only once per cancer type, independent of the number of samples for that patient. However, if a patient has samples of more than one cancer type, the patient will be counted multiple times, once per cancer type. As a consequence, the sum of all counts returned by this function is larger than the total number of patients in Genie.</p> <p>Parameters:</p> <ul> <li> <code>cancer_types_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types not to summarized in the other category. If not specified, all cancer types will be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>         \u2013          <p>number of patients per cancer type</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_cancer_types","title":"<code>get_cancer_types()</code>","text":"<p>Get a list of cancer type names as used in Genie.</p> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>all cancer types used in Genie.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_gene_level_frequencies","title":"<code>get_gene_level_frequencies(gene_symbols, hgvsgs=None, cancer_types=None, cancer_types_to_keep=None, cancer_subtypes=None, cancer_subtypes_to_keep=None, sample_ids=None, cancer_subtype_resolution=False, extra_group_columns=None, universe='ensembl', min_mutations=1, precision=1, panel_coverage_threshold=0.8, impute=False)</code>","text":"<p>Get a mutation frequencies of selected genes across samples.</p> <p>This function returns the gene level mutation frequencies of the specified genes across either all samples or across selected samples after filtering by sample ids or cancer types or cancer subtypes. Counts and frequencies are for patient numbers, not sample numbers. A patient is considered having a particular mutation if at least one sample of this patient has that mutation.</p> <p>The number of genes should be small, because otherwise the volume of results is very high and it will take very long for the function to return.</p> <p>For each mutation detected in at least one sample, it is checked for each sample whether the mutation was tested by the panel used for this sample. Samples not tested for the majority of mutations (less than <code>panel_coverage_threshold</code>) are not included in the returned counts and frequencies. For the remaining samples, missing values are imputed or set to wild type, depending on the <code>impute</code> argument. See <code>get_imputed_sample_mutation_profiles</code> for details. Imputation is very time consuming, and for large enough <code>panel_coverage_threshold</code>s the differences in the results are marginal, which is why imputation is switched off by default.</p> <p>If the <code>cancer_types_to_keep</code> argument is specified, all cancer types not included in this list are summarized in the <code>other</code> category.</p> <p>If the <code>cancer_subtypes_to_keep</code> argument is specified, all cancer subtypes not included in this list are summarized in the <code>other</code> category.</p> <p>If <code>extra_group_columns</code> is specified, counts are provided for each value of these extra columns from sample or patient annotations. One example for this is <code>PRIMARY_RACE</code>, another one is <code>SEX</code>. The argument <code>extra_group_columns</code> needs to be provided as a dictionary, where the dict key is the name of the column, and the dict value is a list of all values of that column for which an extra row in the count table will be provided, while other values will be summarized as <code>other</code>. For example, if counts shall be returned separately for the \"White\", \"Black\" and \"Asian\" population and the remaining patients shall be summarized as \"other\", the <code>extra_group_columns</code> argument needs to be set to <code>{\"PRIMARY_RACE\": [\"White\", \"Black\", \"Asian\"]}</code>. If no aggregation to an <code>other</code> category is desired, set the dict value to <code>None</code>. For example, <code>{\"PRIMARY_RACE\": None}</code> would return separate counts for each race.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes to include in the result.</p> </li> <li> <code>hgvsgs</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>keep only these hvsgs, i.e., exclude all other hgvsgs for the specified gene_symbols. If None, keep all hgvsgs.</p> </li> <li> <code>cancer_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types to include in the result. All if None.</p> </li> <li> <code>cancer_types_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types not to summarize in the other category. No summarization if None.</p> </li> <li> <code>cancer_subtypes</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes to include in the result (Oncotree codes). All if None.</p> </li> <li> <code>cancer_subtypes_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes not to summarize in the other category (Oncotree codes). No summarization if None.</p> </li> <li> <code>sample_ids</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Keep only these samples. No additional filtering if None.</p> </li> <li> <code>cancer_subtype_resolution</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, provide frequencies by cancer subtype, otherwise return frequencies summarized by cancer type. If cancer_subtypes_to_keep is specified, this is automatically set to True, otherwise it defaults to False.</p> </li> <li> <code>extra_group_columns</code>             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>by default, counts are returned for each combination of gene symbol, cancer type (CANCER_TYPE), and possibly cancer subtype (ONCOTREE_CODE). If counts should be split by additional factors, such as PRIMARY_RACE, it can be added here.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> <li> <code>min_mutations</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>Call a gene mutated if it has at least that many mutations. Should be 1 for oncogenes and may be set to 2 for tumor suppressor genes.</p> </li> <li> <code>precision</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>number of fractional digits of formatted allele frequency percentages.</p> </li> <li> <code>panel_coverage_threshold</code>             (<code>float</code>, default:                 <code>0.8</code> )         \u2013          <p>Exclude panels and samples profiled with these panels if the fraction of mutations tested by these panels is below that threshold. If this is set to 1, only panels that test all mutations are included. In that case, no imputation is needed. See <code>get_imputed_sample_muation_profiles</code> for details.</p> </li> <li> <code>impute</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to impute missing values (mutations not tested). If this is set to False (the default), then missing values are replaced with wild type. See <code>get_imputed_sample_muation_profiles</code> for details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>gene level counts and frequencies.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_imputed_sample_mutation_profiles","title":"<code>get_imputed_sample_mutation_profiles(sample_mutation_profiles, panel_coverage_threshold=0.8, impute=False)</code>","text":"<p>Create a sample vs mutation matrix with imputation.</p> <p>This function accepts sample mutation profiles as obtained by the function <code>get_sample_mutation_profiles</code>. The dataframe returned by <code>get_sample_mutation_profiles</code> contains only values (True or False for MUT or WT) for those sample-mutation combinations that were actually tested by the panel used for a sample. For gene level aggregation, a full sample-vs-mutation matrix without missing values is needed.</p> <p>If <code>impute</code> is set to Yes, then this function calculates such a matrix using MICE (Multiple Imputation by Chained Equations) for imputing values. MUT is encoded as 1, WT as 0, and the imputation will result in a fractional number between 0 and 1 for each missing value. Random numbers (uniform distribution between 0 and 1) are then used to assign \u201cMUT\u201d or \u201cWT\u201d depending on the value of the random variable and on the imputed value from MICE. To be more precise, the originally missing value gets a \u201cMUT\u201d if the random number is larger than the imputed value from MICE, and \u201cWT\u201d otherwise. This way we get a full mutation-versus-sample matrix without missing values.</p> <p>Imputation is a time consuming process. For example, imputation for KRAS mutations in NSCLC and CRC with the default panel coverage threshold takes about 15 minutes. If <code>impute</code> is False, all missing values are replaced with \"WT\". For a large <code>panel_coverage_threshold</code>, imputation changes frequencies only marginally. Therefore, imputation is switched off by default.</p> <p>Please be careful when calling this function - the memory requirements for an all genes versus all samples matrix would most likely exceed what is available in the compute environment. Therefore, always work with subsets of genes and maybe also indications.</p> <p>Parameters:</p> <ul> <li> <code>sample_mutation_profiles</code>             (<code>DataFrame</code>)         \u2013          <p>the mutation profiles as obtained by <code>get_sample_mutation_profiles</code>.</p> </li> <li> <code>panel_coverage_threshold</code>             (<code>float</code>, default:                 <code>0.8</code> )         \u2013          <p>Exclude panels and samples profiled with these panels if the fraction of mutations tested by these panels is below that threshold. If this is set to 1, only panels that test all mutations are included. In that case, no imputation is needed.</p> </li> <li> <code>impute</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to impute missing values (mutations not tested). If this is set to False (the default), then missing values are replaced with wild type. Imputation takes very long (maybe hours), and for large <code>panel_coverage_threshold</code>s, frequencies don't change much, which is why imputation is switched off by default.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>Sample-mutation profiles with no missing values.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_nucleic_acid_level_frequencies","title":"<code>get_nucleic_acid_level_frequencies(gene_symbols, hgvsgs=None, cancer_types=None, cancer_types_to_keep=None, cancer_subtypes=None, cancer_subtypes_to_keep=None, sample_ids=None, cancer_subtype_resolution=False, extra_group_columns=None, universe='ensembl', precision=1)</code>","text":"<p>Get a nucleic acid level mutation frequencies.</p> <p>This function returns the mutation frequencies of the specified genes across either all samples or across selected samples after filtering by sample ids or cancer types or cancer subtypes. Counts and frequencies are for patient numbers, not sample numbers. A patient is considered having a particular mutation if at least one sample of this patient has that mutation.</p> <p>The number of genes should be small, because otherwise the volume of results is very high and it will take very long for the function to return.</p> <p>For each mutation detected in at least one sample, it is checked for each sample whether the mutation was tested by the panel used for this sample. Samples not tested for a mutation are not included in the returned counts and frequencies.</p> <p>If the <code>cancer_types_to_keep</code> argument is specified, all cancer types not included in this list are summarized in the <code>other</code> category.</p> <p>If the <code>cancer_subtypes_to_keep</code> argument is specified, all cancer subtypes not included in this list are summarized in the <code>other</code> category.</p> <p>If <code>extra_group_columns</code> is specified, counts are provided for each value of these extra columns. One example for this is <code>PRIMARY_RACE</code>. The argument <code>extra_group_columns</code> needs to be provided as a dictionary, where the dict key is the name of the column, and the dict value is a list of all values of that column for which an extra row in the count table will be provided, while other values will be summarized as <code>other</code>. For example, if counts shall be returned separately for the \"White\", \"Black\" and \"Asian\" population and the remaining patients shall be summarized as \"other\", the <code>extra_group_columns</code> argument needs to be set to <code>{\"PRIMARY_RACE\": [\"White\", \"Black\", \"Asian\"]}</code>. If no aggregation to an <code>other</code> category is desired, set the dict value to <code>None</code>. For example, <code>{\"PRIMARY_RACE\": None}</code> would return separate counts for each race.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes to include in the result.</p> </li> <li> <code>hgvsgs</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>keep only these hvsgs, i.e., exclude all other hgvsgs for the specified gene_symbols. If None, keep all hgvsgs.</p> </li> <li> <code>cancer_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types to include in the result. All if None.</p> </li> <li> <code>cancer_types_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types not to summarize in the other category. No summarization if None.</p> </li> <li> <code>cancer_subtypes</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes to include in the result (Oncotree codes). All if None.</p> </li> <li> <code>cancer_subtypes_to_keep</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes not to summarize in the other category (Oncotree codes). No summarization if None.</p> </li> <li> <code>sample_ids</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>Keep only these samples. No additional filtering if None.</p> </li> <li> <code>cancer_subtype_resolution</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, provide frequencies by cancer subtype, otherwise return frequencies summarized by cancer type. If cancer_subtypes_to_keep is specified, this is automatically set to True, otherwise it defaults to False.</p> </li> <li> <code>extra_group_columns</code>             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>by default, counts are returned for each combination of hgvsg, cancer type (CANCER_TYPE), and possibly cancer subtype (ONCOTREE_CODE). If counts should be split by additional factors, such as PRIMARY_RACE, it can be added here.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> <li> <code>precision</code>             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>number of fractional digits of formatted allele frequency percentages.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_sample_mutation_profiles","title":"<code>get_sample_mutation_profiles(gene_symbols, hgvsgs=None, cancer_types=None, cancer_subtypes=None, sample_ids=None, universe='ensembl')</code>","text":"<p>Get a mutation profile of selected genes across samples.</p> <p>This function returns the mutation profile of the specified genes across either all samples or across selected samples, based on sample ids or cancer types or cancer subtypes. If more than one sample selection criterion is specified, then the intersection of the specified criteria is used to determine the final set of samples. The number of genes should be small, because otherwise the volume of results is very high and it will take very long for the function to return.</p> <p>For each mutation detected in at least one sample, it is checked for each sample whether the mutation was tested by the panel used for this sample. If this is the case, <code>mutated</code> is returned as \"False\", unless the mutation was in fact detected for this sample, in which case \"True\" is returned. Samples that have not been tested for a mutation are not included in the result.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes to include in the result.</p> </li> <li> <code>hgvsgs</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>keep only these hvsgs, i.e., exclude all other hgvsgs for the specified gene_symbols. If None, keep all hgvsgs.</p> </li> <li> <code>cancer_types</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer types to include in the result.</p> </li> <li> <code>cancer_subtypes</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>cancer subtypes to include in the result (Oncotree codes).</p> </li> <li> <code>sample_ids</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>sample identifiers to include in the result.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>Mutation status (MUT or WT) for all tested mutations.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.get_tmb","title":"<code>get_tmb(sample_ids=None, min_genomic_range=10000, tmb_intermediate_threshold=6, tmb_high_threshold=20)</code>","text":"<p>Get the tumor mutational burdon (TMB) for all specified samples.</p> <p>The TMB is calculated by dividing the number of mutations reported for a sample by the total genomic range covered by the panel that is used to profile that sample. If the total genomic range of a panel is smaller than <code>min_genomic_range</code>, NA is returned.</p> <p>Parameters:</p> <ul> <li> <code>sample_ids</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>samples for which the TMB is to be returned. If None (the default), TMB is returned for all GENIE samples.</p> </li> <li> <code>min_genomic_range</code>             (<code>int</code>, default:                 <code>10000</code> )         \u2013          <p>if the total genomic range covered by a panel is smaller that this value, TMB is returned as NA for all samples tested with such a panel.</p> </li> <li> <code>tmb_intermediate_threshold</code>             (<code>int</code>, default:                 <code>6</code> )         \u2013          <p>samples are classified as \"TMB intermediate\" if the TMB is &gt;= this threshold but smaller than <code>tmb_high_threshold</code>. If it is smaller than this threshold, it is classified as \"TMB low\".</p> </li> <li> <code>tmb_high_threshold</code>             (<code>int</code>, default:                 <code>20</code> )         \u2013          <p>samples are classified as \"TMB high\" if the TMB is &gt;= this threshold.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>Table with the mutation count, size of genomic range covered, TMB, and TMB_class for each sample, with SAMPLE_ID as index.</p> </li> </ul>"},{"location":"reference/#genie.genie.Genie.summary","title":"<code>summary()</code>","text":"<p>Get a summary of data in this GENIE release.</p> <p>The summary includes the number of panels, number of patiens, number of samples, number of genes tested by at least one panel, the number of genes with copy number alterations identfied at least once.</p>"},{"location":"reference/#genie.genie.Merger","title":"<code>Merger</code>","text":"<p>Deep merging of dictionary hierarchies.</p> <p>This class can be used to merge two different dictionary trees. This is useful, for example, to load a default configuration from a JSON file and merge it with a user configuration file where the defaults are kept for all values not overwritten by the user configuration file.</p>"},{"location":"reference/#genie.genie.Merger.deep_merge","title":"<code>deep_merge(dict1, dict2)</code>  <code>staticmethod</code>","text":"<p>Deep merging of two hierarchical dictionary trees.</p> <p>The <code>dict1</code> dictionary is updated with any information from <code>dict2</code>. The value of a dictionary item for a particular key can be another dictionary, and a flat merge would simply replace the dictionary item for that key in <code>dict1</code> with the dictionary item from <code>dict2</code>. Such a flat merge would therefore lose the information for that dictionary item from <code>dict1</code>. A deep merge does not drop the value of a dictionary item in <code>dict1</code> and replace it with the dictionary item from <code>dict2</code> with the same key, but instead updates the dictionary item in <code>dict1</code> with the information from <code>dict2</code>, changing or adding only those keys that are part of <code>dict2</code>.</p> <p>Parameters:</p> <ul> <li> <code>dict1</code>             (<code>dict</code>)         \u2013          <p>the dictionary to be updated.</p> </li> <li> <code>dict2</code>             (<code>dict</code>)         \u2013          <p>the dictionary with the update information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>The updated dictionary (<code>dict1</code> updated with <code>dict2</code>).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; genie.Merger.deep_merge(default_config, user_config)\n</code></pre>"},{"location":"reference/#genie.genie.Meta","title":"<code>Meta(config, key)</code>","text":"<p>             Bases: <code>dict</code></p> <p>This class is a dictionary initialized with data from a meta file.</p> <p>GENIE comes with several files with meta information about the actual data files. This class is a dictionary that is initialized with key-value pairs from such a meta information file.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> <li> <code>key</code>             (<code>str</code>)         \u2013          <p>the file name key from the config file.</p> </li> </ul>"},{"location":"reference/#genie.genie.Mutations","title":"<code>Mutations(config)</code>","text":"<p>Mutation data for all samples included in GENIE.</p> <p>Objects of this class contain all SNVs and indels found in any sample in the GENIE data base.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>             (<code>DataFrame</code>)         \u2013          <p>mutation data for all samples.</p> </li> <li> <code>annot</code>             (<code>dict</code>)         \u2013          <p>annotations of mutations derived from re-annotation by ICA. The dictionary has two keys - \"ensembl\" and \"mane\". annot[\"ensembl\"] contains annotations for all Ensembl transcripts in GENIE (GENIE is based on Ensembl transcripts). annot[\"mane\"] contains annotations for all MANE transcripts mapping to the mutations in GENIE.</p> </li> </ul>"},{"location":"reference/#genie.genie.Mutations.get_detected_mutations","title":"<code>get_detected_mutations(gene_symbols, universe='ensembl')</code>","text":"<p>Get detected mutations for a list of genes.</p> <p>This function returns mutations that are found for a the specified genes in all samples included in GENIE. If a mutation is not included in the returned values for a particular sample, this does not mean that the gene is of wild type for this sample because the mutation may not be on the panel used for that sample.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>list of HGNC gene symbols.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>all mutations of these genes found in GENIE samples.</p> </li> </ul>"},{"location":"reference/#genie.genie.Mutations.get_mutation_annotations","title":"<code>get_mutation_annotations(hgvsgs, universe='ensembl')</code>","text":"<p>Get annotations for a list of mutations.</p> <p>Get ICA re-annotations for a list of mutations specified by HGVSG. The returned dataframe can include more than one row per unique genomic variant. For example, a locus can be a downstream_gene_variant for one gene and a 3_prime_UTR_variant for another gene. Furthermore, if the mane universe is specified, there can be a MANE Select and one or more MANE Plus Clinical transcript variants covering the genomic location, and there can be more than one gene covering that location. There can be up to 15 different MANE transcripts for a genomic locus. It depends on the use case which if these transcripts shall be included in downstream analyses. Therefore, the user of this function needs to add appropriate filtering to the returned annotations.</p> <p>Parameters:</p> <ul> <li> <code>hgvsgs</code>             (<code>list</code>)         \u2013          <p>list of HGVSG specifications of mutations.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>Annotations for specified mutations.</p> </li> </ul>"},{"location":"reference/#genie.genie.Mutations.get_sample_mutation_profiles","title":"<code>get_sample_mutation_profiles(gene_symbols, sample_ids, sample_info, tested_mutations, universe='ensembl', hgvsgs=None)</code>","text":"<p>Get mutation profiles of genes for all tested samples.</p> <p>While the function <code>get_detected_mutations</code> returns mutation-sample-pairs only for those samples where a mutation was actually detected, this function adds all samples where a mutation was also tested but not found. The returned dataframe contains a column <code>mutated</code> that is either True or False.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>)         \u2013          <p>genes to include in the result</p> </li> <li> <code>sample_ids</code>             (<code>list</code>)         \u2013          <p>sample identifiers of samples to include</p> </li> <li> <code>sample_info</code>             (<code>SampleInfo</code>)         \u2013          <p>annnotation of all samples</p> </li> <li> <code>tested_mutations</code>             (<code>TestedMutations</code>)         \u2013          <p>cache providing hgvsg vs panel matrix</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> <li> <code>hgvsgs</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>keep only these hvsgs, i.e., exclude all other hgvsgs for the specified gene_symbols. If None, keep all hgvsgs.</p> </li> </ul>"},{"location":"reference/#genie.genie.Mutations.get_unique_mutations","title":"<code>get_unique_mutations(gene_symbols=None, universe='ensembl')</code>","text":"<p>Get a unique list of mutations found in GENIE for a list of genes.</p> <p>For the ensembl universe, all variants affecting Ensembl transcripts that were included in the original GENIE mutation data file are returned. For the mane universe, only variants affecting MANE transcripts are returned.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbols</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>list of genes to query.</p> </li> <li> <code>universe</code>             (<code>str</code>, default:                 <code>'ensembl'</code> )         \u2013          <p>one of \"ensembl\" or \"mane\"; use \"ensembl\" (the default) to include the original Ensembl transcripts from GENIE, and use \"mane\" to use RefSeq MANE transcripts instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>hgvsg for all unique mutations for the specified genes.</p> </li> </ul>"},{"location":"reference/#genie.genie.Mutations.hgvsp3_to_hgvsp1","title":"<code>hgvsp3_to_hgvsp1(hgvsp)</code>","text":"<p>Translate 3-letter amino acid codes to 1-letter amino acid codes.</p> <p>Parameters:</p> <ul> <li> <code>hgvsp</code>             (<code>str</code>)         \u2013          <p>amino acid change with 3-letter amino acid codes</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>hgvsp_short with 1-letter amino acid codes</p> </li> </ul>"},{"location":"reference/#genie.genie.Panel","title":"<code>Panel(config, global_tested_positions, global_panel_info, panel_id)</code>","text":"<p>This class represents a panel (assay) included in GENIE.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> <li> <code>global_tested_positions</code>             (<code>Type[TestedPositions]</code>)         \u2013          <p>tested positions for all panels.</p> </li> <li> <code>global_panel_info</code>             (<code>DataFrame</code>)         \u2013          <p>assay information for all panels.</p> </li> <li> <code>panel_id</code>             (<code>str</code>)         \u2013          <p>the panel identifier.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>id</code>             (<code>str</code>)         \u2013          <p>panel identifier.</p> </li> <li> <code>description</code>             (<code>str</code>)         \u2013          <p>panel description.</p> </li> <li> <code>genes</code>             (<code>list</code>)         \u2013          <p>genes on panel.</p> </li> <li> <code>tested_positions</code>             (<code>TestedPositions</code>)         \u2013          <p>tested position for this panel.</p> </li> <li> <code>panel_info</code>             (<code>dict</code>)         \u2013          <p>assay information for this panel.</p> </li> </ul>"},{"location":"reference/#genie.genie.Panel.gene_is_on_panel","title":"<code>gene_is_on_panel(gene_symbol)</code>","text":"<p>Check if a gene is included in this panel.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbol</code>             (<code>str</code>)         \u2013          <p>HGNC gene symbol.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if gene is on panel, else False.</p> </li> </ul>"},{"location":"reference/#genie.genie.Panel.get_total_range","title":"<code>get_total_range()</code>","text":"<p>Get the overall size of genomic ranges tested by this panel.</p> <p>The overall size of tested genomic regions can be used to estimate TMB.</p> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>Sum of lengths of all ranges tested by this panel.</p> </li> </ul>"},{"location":"reference/#genie.genie.Panel.position_is_tested","title":"<code>position_is_tested(chr, pos)</code>","text":"<p>Check if a genomic position is tested by this panel.</p> <p>Parameters:</p> <ul> <li> <code>chr</code>             (<code>str</code>)         \u2013          <p>chromosome.</p> </li> <li> <code>pos</code>             (<code>int</code>)         \u2013          <p>position on chromosome.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if position is tested by this panel, else False.</p> </li> </ul>"},{"location":"reference/#genie.genie.Panel.range_is_tested","title":"<code>range_is_tested(chr, start_pos, end_pos)</code>","text":"<p>Check if a genomic range is tested by this panel.</p> <p>Parameters:</p> <ul> <li> <code>chr</code>             (<code>str</code>)         \u2013          <p>chromosome.</p> </li> <li> <code>start_pos</code>             (<code>int</code>)         \u2013          <p>start position of range on chromosome.</p> </li> <li> <code>end_pos</code>             (<code>int</code>)         \u2013          <p>end position of range on chromosome.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if entire range is tested by this panel, else False.</p> </li> </ul>"},{"location":"reference/#genie.genie.Panel.tested_positions","title":"<code>tested_positions()</code>","text":"<p>Get all tested positions for this panel.</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>tested positions for this panel.</p> </li> </ul>"},{"location":"reference/#genie.genie.PanelSet","title":"<code>PanelSet(config)</code>","text":"<p>Set of all panels included in GENIE.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>panels</code>             (<code>dict</code>)         \u2013          <p>all panels used by GENIE, with the panel identifier as key and <code>Panel</code> as value.</p> </li> <li> <code>tested_positions</code>             (<code>TestedPositions</code>)         \u2013          <p>tested positions for all panels.</p> </li> <li> <code>tested_mutations</code>             (<code>TestedMutations</code>)         \u2013          <p>tested mutations for all panels.</p> </li> <li> <code>panel_info</code>             (<code>DataFrame</code>)         \u2013          <p>assay information for all panels.</p> </li> </ul>"},{"location":"reference/#genie.genie.PanelSet.panels_for_mutation","title":"<code>panels_for_mutation(hgvsg)</code>","text":"<p>Get a list of all panels testing a particular mutation.</p> <p>This is done using the precomputed</p> <p>Parameters:</p> <ul> <li> <code>hgvsg</code>             (<code>str</code>)         \u2013          <p>mutation to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>dictionary with panel ids as key and <code>Panel</code> objects as values containing all panels testing this mutation.</p> </li> </ul>"},{"location":"reference/#genie.genie.PanelSet.panels_for_position","title":"<code>panels_for_position(chr, pos)</code>","text":"<p>Get a list of all panels testing a genomic locaton.</p> <p>Parameters:</p> <ul> <li> <code>chr</code>             (<code>str</code>)         \u2013          <p>chromosome.</p> </li> <li> <code>pos</code>             (<code>int</code>)         \u2013          <p>position on chromosome.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>List of panels probing this location.</p> </li> </ul>"},{"location":"reference/#genie.genie.PanelSet.panels_for_range","title":"<code>panels_for_range(chr, start_pos, end_pos)</code>","text":"<p>Get a list of all panels testing a genomic range.</p> <p>Parameters:</p> <ul> <li> <code>chr</code>             (<code>str</code>)         \u2013          <p>chromosome.</p> </li> <li> <code>start_pos</code>             (<code>int</code>)         \u2013          <p>start position of range.</p> </li> <li> <code>end_pos</code>             (<code>int</code>)         \u2013          <p>end position of range.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>List of panels probing this range.</p> </li> </ul>"},{"location":"reference/#genie.genie.PatientInfo","title":"<code>PatientInfo(config)</code>","text":"<p>Patient information for all subjects included in GENIE.</p> <p>Patient information includes sex, primary race, ethnicity, clinical center, contact id, dod(?) id, year of contact, dead or alive, year of death.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>             (<code>DataFrame</code>)         \u2013          <p>patient information for all subjects.</p> </li> </ul>"},{"location":"reference/#genie.genie.PatientInfo.append_info","title":"<code>append_info(more_info)</code>","text":"<p>Add more columns to the patient information data.</p> <p>Parameters:</p> <ul> <li> <code>more_info</code>             (<code>DataFrame</code>)         \u2013          <p>table with additional columns to be added to the patient information. This dataframe must have the <code>PATIENT_ID</code> as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>nothing</p> </li> </ul>"},{"location":"reference/#genie.genie.PatientInfo.get_info_for_patient","title":"<code>get_info_for_patient(patient_id)</code>","text":"<p>Get patient information for a single patient.</p> <p>Parameters:</p> <ul> <li> <code>patient_id</code>             (<code>str</code>)         \u2013          <p>patient identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>patient information.</p> </li> </ul>"},{"location":"reference/#genie.genie.SampleInfo","title":"<code>SampleInfo(config)</code>","text":"<p>Sample information for all samples included in GENIE.</p> <p>Sample information includes patient id, age at sequencing, Oncotree code, sample type, sequencing assay id, cancer type, cancer type detailed, sample type detailed.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>             (<code>DataFrame</code>)         \u2013          <p>sample information for all samples.</p> </li> </ul>"},{"location":"reference/#genie.genie.SampleInfo.append_info","title":"<code>append_info(more_info)</code>","text":"<p>Add more columns to the sample information data.</p> <p>Parameters:</p> <ul> <li> <code>more_info</code>             (<code>DataFrame</code>)         \u2013          <p>table with additional columns to be added to the sample information. This dataframe must have the <code>SAMPLE_ID</code> as index.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>nothing</p> </li> </ul>"},{"location":"reference/#genie.genie.SampleInfo.get_info_for_sample","title":"<code>get_info_for_sample(sample_id)</code>","text":"<p>Get sample information for for a single sample.</p> <p>Parameters:</p> <ul> <li> <code>sample_id</code>             (<code>str</code>)         \u2013          <p>sample identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>sample information.</p> </li> </ul>"},{"location":"reference/#genie.genie.SampleInfo.get_sample_ids","title":"<code>get_sample_ids()</code>","text":"<p>Get all sample sample identifiers.</p> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>sample identifiers</p> </li> </ul>"},{"location":"reference/#genie.genie.TestedMutations","title":"<code>TestedMutations(config)</code>","text":"<p>This class knows for each panel-mutation pair if the mutation was tested.</p> <p>Checking if a particular mutation was tested by a panel could be done with the <code>TestedPositions</code> class. However, for thousands of mutations and hundreds of panels this takes quite long (about a day for all mutations detected in GENIE samples and for all panels). Therefore, in a data preparation step done once for each new GENIE release, all mutations found in any sample are checked against all panels and a panel-mutation matrix is created where matrix elements are True if a mutation is tested by a panel, False otherwise.</p> <p>The <code>TestedMutations</code> class uses this precomputed cache file, loading it takes only about 0.5 seconds compared to the about 1 day for computing this on the fly.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>parquet_file</code>             (<code>str</code>)         \u2013          <p>name of parquet cache file.</p> </li> </ul>"},{"location":"reference/#genie.genie.TestedMutations.is_tested_matrix","title":"<code>is_tested_matrix(hgvsgs=None, panels=None)</code>","text":"<p>Get table of mutations versus panels telling if mutation is tested.</p> <p>Get a table with mutations (HGVSGs) as rows and panels as columns where table cells are True or False depending on whether a particular mutation was tested by a particular panel.</p> <p>Parameters:</p> <ul> <li> <code>hgvsgs</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>return table for subset of these mutations (or all mutations if None).</p> </li> <li> <code>panels</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>return table for subset of these panels (or all panels if None). This can be provided as a list of panel identifiers or a list of Panel objects.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table with information which mutation was tested by which panel.</p> </li> </ul>"},{"location":"reference/#genie.genie.TestedPositions","title":"<code>TestedPositions(config)</code>","text":"<p>This class holds all tested positions for all panels.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>Type[Configuration]</code>)         \u2013          <p>the GENIE source data configuration.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>             (<code>DataFrame</code>)         \u2013          <p>tested positions for all panels.</p> </li> </ul>"},{"location":"reference/#genie.genie.TestedPositions.positions_for_panel","title":"<code>positions_for_panel(panel_id)</code>","text":"<p>Get all tested positions for a particular panel.</p> <p>Parameters:</p> <ul> <li> <code>panel_id</code>             (<code>str</code>)         \u2013          <p>the panel identifier.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>tested positions for specified panel.</p> </li> </ul>"}]}